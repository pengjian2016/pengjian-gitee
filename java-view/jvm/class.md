### 1.类文件结构

根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：

```
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//Class 文件的字段属性
    field_info     fields[fields_count];//一个类会可以有多个字段
    u2             methods_count;//Class 文件的方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```
参考：[类文件结构](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84) 更加详细的内容都在这里了。

在这里主要针对常量池做一下说明，在jvm内存结构那一章节中，在方法区的部分有提到常量池相关的内容，分为class常量池、运行时常量池、全局字符串池（全局常量池），它们之间到底是什么样的关系呢？

全局字符串池：

```
全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中
（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。
在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用
（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。
这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

```

class文件常量池:
```

主要存放两大常量：字面量和符号引用。

字面量：如文本字符串、被声明为final的常量值等

符号引用： 是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。

```

![class文件常量池](https://images.gitee.com/uploads/images/2021/0205/104330_fc5e196c_8076629.png "class文件常量池.png")

运行时常量池:

```
当类加载到内存中后，jvm会将class常量池中的内容存放到运行时常量池中，而经过解析（resolve）之后，
也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是上面所说的StringTable，
以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

```

![运行时常量池](https://images.gitee.com/uploads/images/2021/0205/111844_c81c03ac_8076629.png "运行时常量池.png")


### 2.类加载过程

![类加载过程](https://images.gitee.com/uploads/images/2021/0205/112028_e852edbe_8076629.png "类加载过程.png")

类的加载过程主要分为：加载、连接、初始化，其中连接又分为：验证、准备、解析

#### 2.1 加载

- 通过全类名获取定义此类的二进制字节流

- 将字节流所代表的静态存储结构转换为方法区的运行时数据结构

- 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口

加载.class文件的方式：从本地系统中直接加载、通过网络下载.class文件、从zip，jar等归档文件中加载.class文件、从专有数据库中提取.class文件、将Java源文件动态编译为.class文件等。

#### 2.2 验证

确保被加载的类的正确性。

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类（除了java.lang.Object之外）。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

#### 2.3 准备
为类的静态变量分配内存，并将其初始化为默认值。

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配，这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中，这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

例：
```
// 在准备阶段 val1 的初始值是0，在之后的初始化阶段才会真正的赋值3
public static int val1 = 3;
// val2 同时被final和static修饰，它在准备阶段将直接赋值3，我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中
public static final int val2 = 3；

```

#### 2.4 解析
把类中的符号引用转换为直接引用。

符号引用：即用字符串符号的形式来表示引用，实际引用的类、方法或者变量可能还没有被加载到内存中。

直接引用：是有具体引用地址的指针，被引用的类、方法或者变量已经被加载到内存中

符号引用要转换成直接引用才有效，这也说明直接引用的效率要比符号引用高。那为什么要用符号引用呢？这是因为类加载之前，javac会将源代码编译成.class文件，这个时候javac是不知道被编译的类中所引用的类、方法或者变量他们的引用地址在哪里，所以只能用符号引用来表示。

所以解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 2.5 初始化

初始化，为类的静态变量赋予正确的初始值。

只有主动去使用类才会初始化类:

- 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。
  当jvm执行new指令时会初始化类。即当程序创建一个类的实例对象。
  当jvm执行getstatic指令时会初始化类。即程序访问类的静态变量(不是静态常量，常量会被加载到运行时常量池)。
  当jvm执行putstatic指令时会初始化类。即程序给类的静态变量赋值。
  当jvm执行invokestatic指令时会初始化类。即程序调用类的静态方法。
- 使用 java.lang.reflect 包的方法对类进行反射调用时如Class.forname("..."),newInstance()等等。 ，如果类没初始化，需要触发其初始化。
- 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
- 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
- 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。


### 3.类加载器（双亲委派模型）

类的加载过程主要是通过类加载器来完成，JVM 中内置的三个重要的 ClassLoader：

- BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类
- ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包
- AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类

#### 3.1 双亲委派模型

当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类。

** 双亲委派模型的好处是什么？（重要）**

- 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。
- 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全

** 如何实现自定义的类加载器？（重要）**
继承ClassLoader类，实现findClass 方法即可。

** 如果不想遵循双亲委派模型应该怎么做？ **
继承ClassLoader类，重写loadClass方法

强烈建议大家，自己写一个类加载器，跟踪一下类加载的过程。

#### 3.2 类加载器到底执行了类加载过程的哪几个阶段呢?其他阶段由什么东西完成的呢？

待完成

### 4.对象实例化过程

对象的实例化过程是分成两部分：类的初始化，对象的初始化

类的初始化过程在前面 类加载过程中提过，类的初始化是执行类构造器<clinit>(注意不是对象构造器)，为类变量赋值，执行静态代码块等。

对象的初始化过程：参考:[java 内存区域](https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F)

![输入图片说明](https://images.gitee.com/uploads/images/2021/0205/151542_a53f3de9_8076629.png "屏幕截图.png")

- 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

- 分配内存：对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。指针碰撞：内存规整的情况下，已使用的内存在一端，未使用的内存在另一端，利用中间指针像游标一样移动为对象分配内存。空闲列表：内存不规整时，维护一个列表指向空闲区域，分配内存时从列表中选择合适的一块完成分配。

- 初始化零值: 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

- 设置对象头：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

- 初始化：执行<init>方法，将对象中的属性初始化成实际的值。
