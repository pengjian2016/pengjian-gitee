### JVM 常用参数
1.jvm参数设置过哪些？如何设置的？
| 参数  | 描述 |
|-----|----|
| -Xms | 堆的初始大小（启动时分配的内存）  |
| -Xmx | 堆的最大内存，一般与Xms设置成一样（频繁的扩容、缩容将对系统造成极大的压力） |
| -Xmn | 新生代大小，推荐为整个堆的3/8 |
| -Xss | 每个线程的栈大小 |
| -XX:NewRatio|  年轻代(包括Eden和两个Survivor区)与年老代的比值，-XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5如果Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置 | 
| -XX:SurvivorRatio | Eden区与Survivor区的大小比值，如设置为8，则Eden:s0:s1=8:1:1 |
| -XX:ParallelGCThreads	| 并行垃圾收集器的并行线程数，默认4个 |
| -XX:+UseParNewGC | 设置新生代启用并行收集器，其中+号表示布尔值的打开， |
| -XX:+UseParallelOldGC	| 设置老年代启用并行收集器 |
| -XX:+UseConcMarkSweepGC | 启用CMS收集器，CMS主要作用于老年代的收集，如果启用了CMS收集器，则新生代默认采用并行收集器 |
| -XX:+UseG1GC | 启用G1收集器 |
| -XX:+PrintGCDetails | 打印GC详细信息 |
| -XX:+HeapDumpOnOutOfMemoryError | 遇到OOM时打印堆内存快照 |
| -XX:HeapDumpPath=/home/log | 快照保存的位置 |


不同的垃圾回收器，适用于不同的场景。常用的垃圾回收器：

- 串行（Serial）回收器是单线程的一个回收器，简单、易实现、效率高。
- 并行（ParNew）回收器是Serial的多线程版，可以充分的利用CPU资源，减少回收的时间。
- 吞吐量优先（Parallel Scavenge）回收器，侧重于吞吐量的控制。
- 并发标记清除（CMS，Concurrent Mark Sweep）回收器是一种以获取最短回收停顿时间为目标的回收器，该回收器是基于“标记-清除”算法实现的。
- G1，服务端多核CPU、JVM内存占用较大的应用，想要更可控、可预期的GC停顿周期；防止高并发下应用雪崩现象。

### 如何调优？

GC优化一般步骤可以概括为：确定目标、优化参数、验收结果。

#### 确定目标

明确应用程序的系统需求是性能优化的基础，譬如：
- 高可用，可用性达到几个9。
- 低延迟，请求必须多少毫秒内完成响应。 
- 高吞吐，每秒完成多少次事务。

明确系统需求之所以重要，是因为上述性能指标间可能冲突。比如通常情况下，缩小延迟的代价是降低吞吐量或者消耗更多的内存或者两者同时发生。

#### 优化参数

通过收集GC信息，结合系统需求，确定优化方案，例如选用合适的GC回收器、重新设置内存比例、调整JVM参数等。

进行调整后，将不同的优化方案分别应用到多台机器上，然后比较这些机器上GC的性能差异，有针对性的做出选择，再通过不断的试验和观察，找到最合适的参数

#### 验收结果

将修改应用到所有服务器，判断优化结果是否符合预期，总结相关经验

#### 总结

在系统稳定后，多次获取GC数据（多次Full GC后老年代数据大小得出），通过取平均值的方式计算活跃数据的大小

|空间|倍数|
|-----|-----|
| 总大小 | 3-4 倍活跃数据的大小 |
| 新生代 | 1-1.5 活跃数据的大小 |
| 老年代 | 2-3 倍活跃数据的大小 |

假设多次Full GC后的老年代大小为300M，那么总堆大小：300x4=1200M，新生代可以设置为：300x1.5=450M，老年代则：总大小-新生代=750M

以上作为参考，实际当以系统优化目标进行调整。

参考：[从实际案例聊聊Java应用的GC优化](https://tech.meituan.com/2017/12/29/jvm-optimize.html)

### 遇到OOM问题如何排查？

系统自带工具如：

jps 查看java进程

jstat 实时打印gc信息等

jstack 查看线程执行情况，有无死锁
 
jmap 生成堆快照，分析堆内存的使用情况等

图形工具等：

jconsole  

MAT（Memory Analyzer Tool）

VisualVM

参考：[jvm调优工具分析指南](https://juejin.cn/post/6844903501269729288)
