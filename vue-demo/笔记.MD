01 初始vue
==
+  创建一个Vue实例，并且传入一个配置对象
+  root容器符合html规范，root容器代码为【Vue模板】
+  {{xxx}} 自动读取data中的所有属性
+  一旦data数据变化，页面中使用该数据也自动更新 
   
02 模板语法
===
+ 插值语法
  - {{xxx}} 直接都取data数据 
+  指令语法
   -  解析标签  v-bind:href='xxx' 简写[ :hred='xxx' ]

03 数据绑定
==
+ 单向绑定
  + v-bind 数据只能从data流向页面
+ 双向绑定
  + v-model data/页面双向
```
    <div id="root">
      单向绑定<input type="text" v-bind:value="name"><br>
      双向绑定<input type="text" v-model:value="name">
      <!-- v-model 只适用表单元素 -->
      <br>简写<br>
      单向绑定<input type="text" :value="name"><br>
      双向绑定<input type="text" v-model="name">
    </div>
```

04 el与data写法
==
+ el写法
  1. new Vue 配置el属性
  2. 创建Vue实例 通过vm.$mount('#root')指定el属性
+ data写法
  1. 对象
  2. 函数
   
05 mvvm模型
==
> M：模型model-- data中的数据 
> 
> V：视图view-- 模板代码 
> 
> VM: 视图模型viewModel-- Vue实例 

06 数据代理
==
+ Object.defineProperty(person,'age',xxx)
  ```
  xxx{
    value:11
    enumerable:true, //控制属性是否可以枚举，默认值是false
    writable:true, //控制属性是否可以被修改，默认值是false
    configurable:true, //控制属性是否可以被删除，默认值是false
    get(){

    },
    set(){

    }
  }

  ```

07 事件处理
==
+ 基本使用
  + 使用v-on:xxx 或者@xxx绑定事件  xxx事件名称
  + 事件回调需要写在methods对象上 最终会在vm上
  + @click='demo' 或者 @click='demo($event)' 一样,后者可以传参
+ 事件修饰符
  1. prevent 阻止默认事件
  2. stop 阻止事件冒泡
  3. once 事件只触发一次
  4. capture 事件的捕获模式
  5. self 只有event.target操作的元素触发
  6. passive 事件的默认行为立即执行，无需等待事件回调执行完毕
+ 键盘事件
  + 回车 =》enter
  + 删除 =》delete
  + 退出 =》esc
  + 空格 =》space
  + 换行 =》tab
  + 上 => up
  + 下 => down
  + 左 => left
  + 右 => right

08 计算属性
==
+ 要用的属性不存在，要通过已有属性计算得来。
+ 底层借助Object.defineproperty方法提供的setter/getter实现
+ get执行
  + 初次读取执行一次
  + 依赖数据改变再次执行
+ 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。
+ 备注：
    1. 计算属性最终会出现在vm上，直接读取使用即可。
    2. 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。
```
 methods(){
  fullname() {
          return this.firstname + "-" + this.lastname;
        },
 },
computed: {
  fullname2() {
          return this.firstname + "-" + this.lastname;
        },
}

```
09 监视属性
== 
+ 监视属性watch
  + 监视属性变化，自动回调函数
  + 监视的属性必须存在，才能进行监视！！
  + 写法
    + new Vue 传入配置watch
    + 通过vm.$watch

> computed和watch对比
> > +  computed能完成的 watch都可以完成
> > +  watch能完成的 computed不一定能完成  watch可以异步

10 绑定样式
==
+ class样式
  + 写法 :class='xx' xx 可以字符串，对象，数组
    + 字符串写法适用于：类名不确定，要动态获取。
    + 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
    + 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
+ style样式
  + :style='{fontSize:xx}' xx动态值
  + :style='[a,b]' a,b 样式

11 条件渲染
=== 
1. v-if 
   +  写法 （1）v-if='表达式' （2）v-else-if='表达式' （3）v-else='表达式'
   +  适用于：切换频率较低的场景。 
   +  特点：不展示的DOM元素直接被移除。 
   +  注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。
2. v-show
   + v-show='表达式'
   + 适用于：切换频率较高的场景。
   + 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
3. 备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。






































